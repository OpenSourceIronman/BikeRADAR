diff --git a/.gitignore b/.gitignore
index b7faf40..05f4136 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,87 +1,25 @@
+# Text file created by "git diff > diff.txt" command, and sent to ChatGPT to generate git commit messages
+diff.txt
+
+# MacOS directory meta data
+.DS_Store
+
 # Byte-compiled / optimized / DLL files
 __pycache__/
 *.py[codz]
 *$py.class
 
-# C extensions
-*.so
-
-# Distribution / packaging
-.Python
-build/
-develop-eggs/
-dist/
-downloads/
-eggs/
-.eggs/
-lib/
-lib64/
-parts/
-sdist/
-var/
-wheels/
-share/python-wheels/
-*.egg-info/
-.installed.cfg
-*.egg
-MANIFEST
-
-# PyInstaller
-#  Usually these files are written by a python script from a template
-#  before PyInstaller builds the exe, so as to inject date/other infos into it.
-*.manifest
-*.spec
-
-# Installer logs
-pip-log.txt
-pip-delete-this-directory.txt
-
-# Unit test / coverage reports
-htmlcov/
-.tox/
-.nox/
-.coverage
-.coverage.*
-.cache
-nosetests.xml
-coverage.xml
-*.cover
-*.py.cover
-.hypothesis/
-.pytest_cache/
-cover/
-
-# Translations
-*.mo
-*.pot
-
-# Django stuff:
-*.log
-local_settings.py
+# SQLite Stuff
+.db
+.db-journal
+.db-wal
+.db-shm
 db.sqlite3
 db.sqlite3-journal
 
-# Flask stuff:
-instance/
-.webassets-cache
-
-# Scrapy stuff:
-.scrapy
-
-# Sphinx documentation
-docs/_build/
-
-# PyBuilder
-.pybuilder/
-target/
-
 # Jupyter Notebook
 .ipynb_checkpoints
 
-# IPython
-profile_default/
-ipython_config.py
-
 # pyenv
 #   For a library or package, you might want to ignore these files since the code is
 #   intended to run in multiple environments; otherwise, check them in:
@@ -100,40 +38,9 @@ ipython_config.py
 #   commonly ignored for libraries.
 #uv.lock
 
-# poetry
-#   Similar to Pipfile.lock, it is generally recommended to include poetry.lock in version control.
-#   This is especially recommended for binary packages to ensure reproducibility, and is more
-#   commonly ignored for libraries.
-#   https://python-poetry.org/docs/basic-usage/#commit-your-poetrylock-file-to-version-control
-#poetry.lock
-#poetry.toml
-
-# pdm
-#   Similar to Pipfile.lock, it is generally recommended to include pdm.lock in version control.
-#   pdm recommends including project-wide configuration in pdm.toml, but excluding .pdm-python.
-#   https://pdm-project.org/en/latest/usage/project/#working-with-version-control
-#pdm.lock
-#pdm.toml
-.pdm-python
-.pdm-build/
-
-# pixi
-#   Similar to Pipfile.lock, it is generally recommended to include pixi.lock in version control.
-#pixi.lock
-#   Pixi creates a virtual environment in the .pixi directory, just like venv module creates one
-#   in the .venv directory. It is recommended not to include this directory in version control.
-.pixi
-
 # PEP 582; used by e.g. github.com/David-OConnor/pyflow and github.com/pdm-project/pdm
 __pypackages__/
 
-# Celery stuff
-celerybeat-schedule
-celerybeat.pid
-
-# SageMath parsed files
-*.sage.py
-
 # Environments
 .env
 .envrc
@@ -144,64 +51,12 @@ ENV/
 env.bak/
 venv.bak/
 
-# Spyder project settings
-.spyderproject
-.spyproject
-
-# Rope project settings
+# Rope project settings generated by Zed IDE
 .ropeproject
 
-# mkdocs documentation
-/site
-
-# mypy
-.mypy_cache/
-.dmypy.json
-dmypy.json
-
-# Pyre type checker
-.pyre/
-
-# pytype static type analyzer
-.pytype/
-
-# Cython debug symbols
-cython_debug/
-
-# PyCharm
-#  JetBrains specific template is maintained in a separate JetBrains.gitignore that can
-#  be found at https://github.com/github/gitignore/blob/main/Global/JetBrains.gitignore
-#  and can be added to the global gitignore or merged into this file.  For a more nuclear
-#  option (not recommended) you can uncomment the following to ignore the entire idea folder.
-#.idea/
-
-# Abstra
-# Abstra is an AI-powered process automation framework.
-# Ignore directories containing user credentials, local state, and settings.
-# Learn more at https://abstra.io/docs
-.abstra/
-
-# Visual Studio Code
-#  Visual Studio Code specific template is maintained in a separate VisualStudioCode.gitignore 
-#  that can be found at https://github.com/github/gitignore/blob/main/Global/VisualStudioCode.gitignore
-#  and can be added to the global gitignore or merged into this file. However, if you prefer, 
-#  you could uncomment the following to ignore the entire vscode folder
-# .vscode/
-
-# Ruff stuff:
-.ruff_cache/
-
-# PyPI configuration file
-.pypirc
-
 # Cursor
 #  Cursor is an AI-powered code editor. `.cursorignore` specifies files/directories to
 #  exclude from AI features like autocomplete and code analysis. Recommended for sensitive data
 #  refer to https://docs.cursor.com/context/ignore-files
 .cursorignore
 .cursorindexingignore
-
-# Marimo
-marimo/_static/
-marimo/_lsp/
-__marimo__/
diff --git a/Radar.py b/Radar.py
index 59376be..3f87afa 100644
--- a/Radar.py
+++ b/Radar.py
@@ -10,6 +10,9 @@ import plotly.graph_objects as go   # pip install plotly
 # Internal libraries
 from StationaryObject import StationaryObject
 
+speedInMetersPerSecond = 10
+pollingRateInHz = 2
+
 class Radar:
 
     PAST = 0
@@ -25,6 +28,13 @@ class Radar:
     EIGHTH_CIRCLE = int(FULL_CIRCLE / 8)
 
     def __init__(self, maxRadius: int = 300, port: str = '/dev/ttyUSB0', mode: str = 'TESTING'):
+        """Initialize the Radar object.
+
+        Args:
+            maxRadius (int, optional): Maximum range of the RADAR in meters. Defaults to 300.
+            port (str, optional): Serial port for communication. Defaults to '/dev/ttyUSB0'.
+            mode (str, optional): Operating mode ('TESTING' or 'PRODUCTION'). Defaults to 'TESTING'.
+        """
 
         if mode == "TESTING":
             self.mode = mode
@@ -106,12 +116,30 @@ class Radar:
 
 
     def cartesian_to_polar(x, y):
+        """ Convert Cartesian coordinates to polar coordinates.
+
+        Args:
+            x (float): The x-coordinate.
+            y (float): The y-coordinate.
+
+        Returns:
+            tuple: A tuple containing the radius and angle in degrees.
+        """
         r = math.sqrt(x**2 + y**2)
         theta = math.degrees(math.atan2(y, x))
         return (r, theta)
 
 
     def polar_to_cartesian(r, thetaDegrees):
+        """ Convert polar coordinates to Cartesian coordinates.
+
+        Args:
+            r (float): The radius.
+            thetaDegrees (float): The angle in degrees.
+
+        Returns:
+            tuple: A tuple containing the x and y coordinates.
+        """
         thetaRadians = math.radians(thetaDegrees)
         x = r * math.cos(thetaRadians)
         y = r * math.sin(thetaRadians)
@@ -125,29 +153,30 @@ class Radar:
             velocity (int): The velocity of the moving RADAR module
             pollRate (int): The rate at which the data is polled in Hertz
         """
-        stationaryObjects = []
+
         radiusMoved = velocity * pollRate
         for r in range(1, self.maxRadius - radiusMoved):
             for t in range(Radar.FULL_CIRCLE):
-                if self.dataTimeSliceCurrent[r, t] == self.dataTimeSlicePast[(r+radiusMoved), t]:
+                if self.dataTimeSliceCurrent[r, t] and self.dataTimeSlicePast[(r+radiusMoved), t]:
                     self.dataTimeSliceStationary[r, t] = True
-                    #obj = StationaryObject
-                    #obj.add_point(r, t)
-                    #stationaryObjects.append(obj)
 
-        #return stationaryObjects
 
 
     def scan(self, currentPlotContainer):
+        global speedInMetersPerSecond, pollingRateInHz
+
         print("Scanning...")
 
         self.reset_current_radar_database()
 
         if self.mode == "TESTING":
-            self.generate_random_data(100)
-            #self.serialConnection.write(b'1_1111_0001_0101_1010_1010_1010_1010_1010_1010_1000_1111\n')   # 45 bits for 45 degrees = Radar.EIGHTH_CIRCLE
-            #data = self.serialConnection.read(Radar.EIGHTH_CIRCLE)
-            #print(f"Data:{data}")
+            #self.generate_random_data(100)
+            self.manual_update()
+            self.serialConnection.write(b'1_1111_0001_0101_1010_1010_1010_1010_1010_1010_1000_1111')   # 45 bits for 45 degrees = Radar.EIGHTH_CIRCLE
+            data = self.serialConnection.read(Radar.EIGHTH_CIRCLE)
+            dataStr = data.decode('utf-8').replace('_', '')
+            binary = bin(int(dataStr))
+            print(f"Data: {data} = {binary})")
         else:
             self.generate_random_data(100)
             #data = self.serialConnection.read(Radar.FULL_CIRCLE)
@@ -165,12 +194,34 @@ class Radar:
         currentPlotContainer.figure = self.GUI("CURRENT")
         currentPlotContainer.update()
 
+        self.stationaryObjects = []
+        self.find_stationary_points(speedInMetersPerSecond, pollingRateInHz)
+        #print(f"Stationary Data: {self.dataTimeSliceStationary}")
+        stationaryGroupedPoints = self.group_points(self.dataTimeSliceStationary)
+        print(f"Group ID Data: {stationaryGroupedPoints}")
+        groupId = 0
+        if len(stationaryGroupedPoints) > 0:
+            for i in range(stationaryGroupedPoints[-1][Radar.GROUP_ID]+1):
+                obj = StationaryObject()
+                for point in stationaryGroupedPoints:
+                    if point[Radar.GROUP_ID] == groupId:
+                        obj.add_point(point[Radar.RADIUS], point[Radar.THETA])
+                obj.define_object_outer_polyline()
+                groupId += 1
+                self.stationaryObjects.append(obj)
+
+        print("Stationary Objects:", self.stationaryObjects)
+        stationaryPlotContainer.figure = self.GUI("STATIONARY OBJECTS")
+        stationaryPlotContainer.update()
+
 
     def next_scan(self, currentPlotContainer, pastPlotContainer):
-        self.find_stationary_points(10, 2)
-        self.group_points(self.dataTimeSliceStationary)
+        """ Lambda function to update the plot containers with new Plotly figures based on the current and past RADAR data.
 
-        # Update the plot containers with new Plotly figures
+        Args:
+            currentPlotContainer (PlotContainer): The container for the current plot.
+            pastPlotContainer (PlotContainer): The container for the past plot.
+        """
         self.dataTimeSlicePast = self.dataTimeSliceCurrent.copy()
         pastPlotContainer.figure = self.GUI("PAST")
         pastPlotContainer.update()
@@ -179,10 +230,19 @@ class Radar:
 
 
     def reset_current_radar_database(self):
+        """ Reset the current RADAR database."""
         self.dataTimeSliceCurrent = np.zeros((self.maxRadius, Radar.FULL_CIRCLE), dtype=bool)
 
 
     def update_radar_database(self, data: bool, r: int, theta: int, timeSlice):
+        """ Update the RADAR database with new data.
+
+        Args:
+            data (bool): The new data to be stored.
+            r (int): The radius coordinate.
+            theta (int): The angle coordinate.
+            timeSlice (int): The time slice to update.
+        """
         if timeSlice == Radar.PAST:
             self.dataTimeSlicePast[r, theta] = data
         elif timeSlice == Radar.CURRENT:
@@ -194,14 +254,20 @@ class Radar:
 
 
     def generate_random_data(self, numOfPoints, theta: int = FULL_CIRCLE):
+        """Generate random data for the radar.
+
+        Args:
+            numOfPoints (int): The number of points to generate.
+            thetaMax (int): The maxium angle coordinate.
+        """
         for _ in range(numOfPoints):
             self.update_radar_database(True, np.random.randint(1, self.maxRadius), np.random.randint(0, Radar.FULL_CIRCLE), Radar.CURRENT)
 
 
     def manual_update(self):
         self.update_radar_database(True, 60, 0, Radar.PAST)
-        self.update_radar_database(True, 50, 0, Radar.CURRENT)
-        self.update_radar_database(True, 100, 0, Radar.CURRENT)
+        self.update_radar_database(True, 40, 0, Radar.CURRENT)
+        self.update_radar_database(True, 80, 0, Radar.CURRENT)
         self.update_radar_database(True, 100, 359, Radar.CURRENT)
         self.update_radar_database(True, 100, 1, Radar.CURRENT)
         self.update_radar_database(True, 100, 2, Radar.CURRENT)
@@ -210,7 +276,6 @@ class Radar:
         self.update_radar_database(True, 102, 4, Radar.CURRENT)
         self.update_radar_database(True, 108, 5, Radar.CURRENT)
         self.update_radar_database(True, 103, 4, Radar.CURRENT)
-        self.update_radar_database(True, 40, 0, Radar.NEXT)
 
 
     def create_plot_points(self, data):
@@ -225,7 +290,8 @@ class Radar:
         radiusPlotPoints = []
         thetaPlotPoints = []
 
-        #data = self.group_points(dataInput)
+        #dataGrouped = self.group_points(data)
+        #print(f"Data with Grouped Points: {dataGrouped}")
 
         for r in range(self.maxRadius):
             for t in range(Radar.FULL_CIRCLE):
@@ -237,6 +303,14 @@ class Radar:
 
 
     def GUI(self, timeSlice: str):
+        """Create a Plotly figure for the GUI using input RADAR data.
+
+        Args:
+            timeSlice (str): The time slice to display.
+
+        Returns:
+            go.Figure: The Plotly figure.
+        """
 
         if timeSlice == "CURRENT":
             radiusList, thetaList = self.create_plot_points(self.dataTimeSliceCurrent)
@@ -260,34 +334,41 @@ class Radar:
             polar=dict(
                 bgcolor="#4d4d4d",
                 radialaxis=dict(visible=True, range=[0, self.maxRadius], tickvals=[100, 200]),
-                angularaxis=dict(rotation=90, direction="clockwise",)   # rotate CCW
+                angularaxis=dict(rotation=90, direction="clockwise")  # Set numbering direction to clockwise like a compass and rotate 90 degree counterclockwise
             ),
-            font=dict(color="white"),
-            #showlegend=True
+            font=dict(color="white")
         )
 
         return figure
 
 
     def toggle_GUI(value):
+        """ Toggle the visibility of the GUI plots based on the selected time slice.
+
+        Args:
+            value (str): The selected time slice ("CURRENT", "PAST", or "STATIONARY OBJECTS").
+        """
         if value == "CURRENT":
             pastPlotContainer.visible = False
+            stationaryPlotContainer.visible = False
             currentPlotContainer.visible = True
         elif value == "PAST":
             currentPlotContainer.visible = False
+            stationaryPlotContainer.visible = False
             pastPlotContainer.visible = True
         elif value == "STATIONARY OBJECTS":
             currentPlotContainer.visible = False
             pastPlotContainer.visible = False
+            stationaryPlotContainer.visible = True
         else:
-            raise ValueError("Invalid time slice")
+            raise ValueError("DEV ERROR: Invalid time slice radio button selected!")
 
 
 if __name__ in {"__main__", "__mp_main__"}:
 
     EP3 = Radar(300, '/dev/ttyUSB0', 'TESTING')
-    EP3.generate_random_data(100)
-    EP3.update_radar_database(True, 60, 0, Radar.PAST)
+    #EP3.generate_random_data(100)
+    EP3.manual_update()
 
     with ui.row().classes('justify-center w-full'):
         currentPlotContainer = ui.plotly(EP3.GUI("CURRENT")).classes('w-[600px] h-[525px]')
@@ -296,7 +377,7 @@ if __name__ in {"__main__", "__mp_main__"}:
         pastPlotContainer.visible = False
         stationaryPlotContainer.visible = False
 
-    ui.button("Perform new RADAR scan", icon='radar', on_click= lambda: EP3.next_scan(currentPlotContainer, pastPlotContainer)).props('color=orange').classes('justify-center w-full')
+    ui.button("PERFORM NEW RADAR SCAN", icon='radar', on_click= lambda: EP3.next_scan(currentPlotContainer, pastPlotContainer)).props('color=orange').classes('justify-center w-full')
     with ui.row().classes('items-center'):
         ui.label("RADAR Time Slice:")
         radioTimeSliceInput = ui.radio(["CURRENT", "PAST", "STATIONARY OBJECTS"], value="CURRENT", on_change= lambda e: Radar.toggle_GUI(e.value)).props('inline').classes('mr-2')
diff --git a/diff.txt b/diff.txt
index 5972655..69f4a04 100644
--- a/diff.txt
+++ b/diff.txt
@@ -1,460 +0,0 @@
-diff --git a/Radar.py b/Radar.py
-index 534cb4c..59376be 100644
---- a/Radar.py
-+++ b/Radar.py
-@@ -1,58 +1,73 @@
- #!/usr/bin/python3
- 
- # External libraries
--from nicegui import Tailwind, ui
--import numpy as np
--#import serial
--import math
--import plotly.graph_objects as go
--from collections import defaultdict, deque
-+from nicegui import ui              # pip install nicegui
-+import numpy as np                  # pip install numpy
-+import serial                       # pip install pyserial
-+import math                         # pip install math
-+import plotly.graph_objects as go   # pip install plotly
- 
-+# Internal libraries
- from StationaryObject import StationaryObject
- 
--PAST = 0
--CURRENT = 1
--NEXT = 2
-+class Radar:
- 
--RADIUS = 0
--THETA = 1
--GROUP_ID = 2
-+    PAST = 0
-+    CURRENT = 1
-+    NEXT = 2
- 
--FULL_CIRCLE = 360
-+    RADIUS = 0
-+    THETA = 1
-+    GROUP_ID = 2
- 
--class Radar:
--    def __init__(self, maxRadius: int = 300, port: str = '/dev/ttyUSB0'):
--        #self.serialConnection = serial.Serial(port, 9600)
-+    FULL_CIRCLE = 360
-+    QUARTER_CIRCLE = int(FULL_CIRCLE / 4)
-+    EIGHTH_CIRCLE = int(FULL_CIRCLE / 8)
-+
-+    def __init__(self, maxRadius: int = 300, port: str = '/dev/ttyUSB0', mode: str = 'TESTING'):
-+
-+        if mode == "TESTING":
-+            self.mode = mode
-+            self.serialConnection = serial.serial_for_url('loop://', timeout=1)
-+        else:
-+            # Initialize production serial connection with USB port at 9600 baud rate
-+            self.serialConnection = serial.Serial(port, 9600)
- 
--        #
-+        # Max range of the radar in meters
-         self.maxRadius = maxRadius
- 
--        # Create a 2D array (len(radius) x len(theta)) filled with zeros
--        self.dataTimeSlicePast = np.zeros((maxRadius, FULL_CIRCLE), dtype=bool)
--        self.dataTimeSliceCurrent = np.zeros((maxRadius, FULL_CIRCLE), dtype=bool)
--        self.dataTimeSliceNext = np.zeros((maxRadius, FULL_CIRCLE), dtype=bool)
-+        # Create a 2D array (len(radius) x len(theta)) filled with False
-+        self.dataTimeSlicePast = np.zeros((maxRadius, Radar.FULL_CIRCLE), dtype=bool)
-+        self.dataTimeSliceCurrent = np.zeros((maxRadius, Radar.FULL_CIRCLE), dtype=bool)
-+        self.dataTimeSliceStationary = np.zeros((maxRadius, Radar.FULL_CIRCLE), dtype=bool)
- 
-         # Uses StationaryObject Dataclass
-         self.stationaryObjects = []
- 
-+
-     def __str__(self):
-         return f"RadarPlot(dataTimeSlicePast={self.dataTimeSlicePast}, dataTimeSliceCurrent={self.dataTimeSliceCurrent}, dataTimeSliceNext={self.dataTimeSliceNext}, stationaryObjects={self.stationaryObjects})"
- 
--    def get_points(self):
--        """
--        Returns a list of points representing radar plot points.
-+
-+    def group_points(self, dataTimeSlice):
-+        """ Group points by adjacency and add a group ID for all touch points.
- 
-         Each point is a list of (radius, theta, group_id).
-         Grouping algorithm only works because dataTimeSliceCurrent is built scanining theta from 0 to 259 before incrementing radius by one
-         """
- 
-         points = []
-+        pointsSortedByRadius = []
-+        pointsSortedByTheta = []
-         groupId = 0
- 
-+        # Get points from current data time slice with group ID set to 0
-         for r in range(self.maxRadius):
--            for t in range(FULL_CIRCLE):
--                if self.dataTimeSliceCurrent[r, t]:
--                    points.append([r, t, groupId])
-+            for t in range(Radar.FULL_CIRCLE):
-+                if dataTimeSlice[r, t]:
-+                    points.append([r, t, groupId])  # Sort by radius
-+
-+        #print(f"Raw Data: {points}")
- 
-         # Group points by adjacency
-         for i in range(1, len(points)):
-@@ -60,131 +75,160 @@ class Radar:
-             curr = points[i]
- 
-             # Check adjacency by theta or radius
--            if (0 <= abs(prev[THETA] - curr[THETA]) <= 1 or abs(prev[THETA] - curr[THETA]) == FULL_CIRCLE - 1) and abs(prev[RADIUS] - curr[RADIUS]) <= 1:
--                curr[GROUP_ID] = prev[GROUP_ID]
-+            if (0 <= abs(prev[Radar.THETA] - curr[Radar.THETA]) <= 1 or abs(prev[Radar.THETA] - curr[Radar.THETA]) == Radar.FULL_CIRCLE - 1) and abs(prev[Radar.RADIUS] - curr[Radar.RADIUS]) <= 1:
-+                curr[Radar.GROUP_ID] = prev[Radar.GROUP_ID]
-             else:
-                 groupId += 1
--                curr[GROUP_ID] = groupId
-+                curr[Radar.GROUP_ID] = groupId
-+
-+        pointsSortedByRadius = sorted(points, key=lambda x: x[Radar.RADIUS])
-+        pointsSortedByTheta = sorted(points, key=lambda x: x[Radar.THETA])
-+
-+        #print(pointsSortedByRadius)
-+        #print(pointsSortedByTheta)
-+
-+        # Group points by adjacency
-+        for i in range(1, len(pointsSortedByTheta)):
-+            prev = pointsSortedByTheta[i-1]
-+            curr = pointsSortedByTheta[i]
- 
--        return points
-+            # Check adjacency by theta or radius
-+            if abs(prev[Radar.RADIUS] - curr[Radar.RADIUS]) <= 1 and abs(prev[Radar.THETA] - curr[Radar.THETA]) <= 1:
-+                curr[Radar.GROUP_ID] = prev[Radar.GROUP_ID]
-+            else:
-+                pass
-+
-+        finalGroupedPoints = sorted(pointsSortedByTheta, key=lambda x: x[Radar.GROUP_ID])
-+        #print(f"Final Grouping: {finalGroupedPoints}")
-+        print(f"Number of groups: {len(set(point[Radar.GROUP_ID] for point in finalGroupedPoints))}")
-+
-+        return finalGroupedPoints
- 
--    def cartesian_time_slice():
--        pass
- 
-     def cartesian_to_polar(x, y):
-         r = math.sqrt(x**2 + y**2)
-         theta = math.degrees(math.atan2(y, x))
-         return (r, theta)
- 
-+
-     def polar_to_cartesian(r, thetaDegrees):
-         thetaRadians = math.radians(thetaDegrees)
-         x = r * math.cos(thetaRadians)
-         y = r * math.sin(thetaRadians)
-         return (x, y)
- 
--    def update_group_id(self):
--        points = self.find_points()
--
--        for i in range(len(points)):
--            if points[i][THETA] == 359:
--                pass
--
--    def group_points_CHATGPT(self):
--        points = self.get_points()
--        print(points)
- 
--        points_by_obj = defaultdict(list)
--        for r, theta, obj in points:
--            points_by_obj[obj].append((r, theta, obj))
--        print(points_by_obj)
-+    def find_stationary_points(self, velocity: int, pollRate: int = 2):
-+        """" Determine if consecutive time slices contain stationary objects.
- 
-+        Args:
-+            velocity (int): The velocity of the moving RADAR module
-+            pollRate (int): The rate at which the data is polled in Hertz
-+        """
-+        stationaryObjects = []
-+        radiusMoved = velocity * pollRate
-+        for r in range(1, self.maxRadius - radiusMoved):
-+            for t in range(Radar.FULL_CIRCLE):
-+                if self.dataTimeSliceCurrent[r, t] == self.dataTimeSlicePast[(r+radiusMoved), t]:
-+                    self.dataTimeSliceStationary[r, t] = True
-+                    #obj = StationaryObject
-+                    #obj.add_point(r, t)
-+                    #stationaryObjects.append(obj)
- 
--        clusters = []
--        new_group_counter = 0
-+        #return stationaryObjects
- 
--        for obj, pts in points_by_obj.items():
--            print(f"pts: {pts} & Obj: {obj}")
--            visited = [False] * len(pts)
--            for i, point in enumerate(pts):
--                if visited[i]:
--                    continue
- 
--                cluster = []
--                queue = deque([i])
--                visited[i] = True
-+    def scan(self, currentPlotContainer):
-+        print("Scanning...")
- 
--                while queue:
--                    j = queue.popleft()
--                    cluster.append(pts[j])
--                    rj, thetaj, _ = pts[j]
--                    for k, (rk, thetak, _) in enumerate(pts):
--                        if not visited[k]:
--                            if abs(rj - rk) <= 1 or abs(thetaj - thetak) <= 1:
--                                visited[k] = True
--                                queue.append(k)
-+        self.reset_current_radar_database()
- 
--                # Decide objectId for this cluster
--                if len(cluster) == 1:
--                    # Create a new label (C, D, etc.)
--                    new_group_counter += 1
--                    new_id = chr(ord('C') + new_group_counter - 1)
--                    cluster = [(r, t, new_id) for (r, t, _) in cluster]
--                else:
--                    cluster = [(r, t, obj) for (r, t, _) in cluster]
-+        if self.mode == "TESTING":
-+            self.generate_random_data(100)
-+            #self.serialConnection.write(b'1_1111_0001_0101_1010_1010_1010_1010_1010_1010_1000_1111\n')   # 45 bits for 45 degrees = Radar.EIGHTH_CIRCLE
-+            #data = self.serialConnection.read(Radar.EIGHTH_CIRCLE)
-+            #print(f"Data:{data}")
-+        else:
-+            self.generate_random_data(100)
-+            #data = self.serialConnection.read(Radar.FULL_CIRCLE)
- 
--                clusters.append(cluster)
-+        #i = 0
-+        #for r in range(self.maxRadius):
-+        #    for t in range(Radar.FULL_CIRCLE):
-+        #        bit = data[i:i+1]
-+        #        #print(bit)
-+        #        if bit:
-+        #            self.update_radar_database(True, r, t, Radar.CURRENT)
-+        #        else:
-+        #            self.update_radar_database(False, r, t, Radar.CURRENT)
- 
--        return clusters
-+        currentPlotContainer.figure = self.GUI("CURRENT")
-+        currentPlotContainer.update()
- 
- 
--    def find_stationary_points(self, velocity: int, pollRate: int = 2):
--        """" Determine if consecutive time slices contain stationary objects.
-+    def next_scan(self, currentPlotContainer, pastPlotContainer):
-+        self.find_stationary_points(10, 2)
-+        self.group_points(self.dataTimeSliceStationary)
- 
--        Args:
--            velocity (int): The velocity of the moving RADAR module
--            pollRate (int): The rate at which the data is polled in Hertz
--        """
--        stationaryObjects = []
--        for r in range(self.maxRadius):
--            for t in range(FULL_CIRCLE):
--                radiusMoved = velocity * pollRate
--                if self.dataTimeSliceCurrent[r, t] == self.dataTimeSlicePast[(r+radiusMoved), t]:
--                    obj = StationaryObject
--                    obj.add_point(r, t)
--                    stationaryObjects.append(obj)
-+        # Update the plot containers with new Plotly figures
-+        self.dataTimeSlicePast = self.dataTimeSliceCurrent.copy()
-+        pastPlotContainer.figure = self.GUI("PAST")
-+        pastPlotContainer.update()
- 
--        return stationaryObjects
-+        self.scan(currentPlotContainer)
- 
--    def scan(self):
--        for r in range(self.maxRadius):
--            for t in range(FULL_CIRCLE):
--                data = self.serialConnection.read()
--                if data == b'1':
--                    self.update_radar(True, r, t)
--                else:
--                    self.update_radar(False, r, t)
- 
--    def next_scan(self):
--        self.dataTimeSlicePast = self.dataTimeSliceCurrent
--        self.dataTimeSliceCurrent = self.scan()
-+    def reset_current_radar_database(self):
-+        self.dataTimeSliceCurrent = np.zeros((self.maxRadius, Radar.FULL_CIRCLE), dtype=bool)
- 
- 
--    def update_radar(self, data: bool, r: int, theta: int, timeSlice):
--        if timeSlice == PAST:
-+    def update_radar_database(self, data: bool, r: int, theta: int, timeSlice):
-+        if timeSlice == Radar.PAST:
-             self.dataTimeSlicePast[r, theta] = data
--        elif timeSlice == CURRENT:
-+        elif timeSlice == Radar.CURRENT:
-             self.dataTimeSliceCurrent[r, theta] = data
--        elif timeSlice == NEXT:
-+        elif timeSlice == Radar.NEXT:
-             self.dataTimeSliceNext[r, theta] = data
-         else:
-             raise ValueError("Invalid time slice")
- 
-+
-+    def generate_random_data(self, numOfPoints, theta: int = FULL_CIRCLE):
-+        for _ in range(numOfPoints):
-+            self.update_radar_database(True, np.random.randint(1, self.maxRadius), np.random.randint(0, Radar.FULL_CIRCLE), Radar.CURRENT)
-+
-+
-+    def manual_update(self):
-+        self.update_radar_database(True, 60, 0, Radar.PAST)
-+        self.update_radar_database(True, 50, 0, Radar.CURRENT)
-+        self.update_radar_database(True, 100, 0, Radar.CURRENT)
-+        self.update_radar_database(True, 100, 359, Radar.CURRENT)
-+        self.update_radar_database(True, 100, 1, Radar.CURRENT)
-+        self.update_radar_database(True, 100, 2, Radar.CURRENT)
-+        self.update_radar_database(True, 100, 3, Radar.CURRENT)
-+        self.update_radar_database(True, 101, 3, Radar.CURRENT)
-+        self.update_radar_database(True, 102, 4, Radar.CURRENT)
-+        self.update_radar_database(True, 108, 5, Radar.CURRENT)
-+        self.update_radar_database(True, 103, 4, Radar.CURRENT)
-+        self.update_radar_database(True, 40, 0, Radar.NEXT)
-+
-+
-     def create_plot_points(self, data):
-+        """ Create plot points for the GUI graph using input RADAR data.
-+
-+        Args:
-+            data (numpy.ndarray): The radar data.
-+
-+        Returns:
-+            tuple: A tuple containing the radius plot points and theta plot points.
-+        """
-         radiusPlotPoints = []
-         thetaPlotPoints = []
- 
-+        #data = self.group_points(dataInput)
-+
-         for r in range(self.maxRadius):
--            for t in range(FULL_CIRCLE):
-+            for t in range(Radar.FULL_CIRCLE):
-                 if data[r, t]:
-                     radiusPlotPoints.append(r)
-                     thetaPlotPoints.append(t)
-@@ -192,50 +236,69 @@ class Radar:
-         return radiusPlotPoints, thetaPlotPoints
- 
- 
-+    def GUI(self, timeSlice: str):
-+
-+        if timeSlice == "CURRENT":
-+            radiusList, thetaList = self.create_plot_points(self.dataTimeSliceCurrent)
-+        elif timeSlice == "PAST":
-+            radiusList, thetaList = self.create_plot_points(self.dataTimeSlicePast)
-+        elif timeSlice == "STATIONARY OBJECTS":
-+            radiusList, thetaList = self.create_plot_points(self.dataTimeSliceStationary)
-+        else:
-+            raise ValueError("Invalid time slice")
-+
-+
-+        figure = go.Figure(go.Scatterpolar(r= radiusList, theta= thetaList,
-+            mode="markers",
-+            marker=dict(size=4, color="red"),
-+            name="Detection"))
-+
-+        figure.update_layout(
-+            margin=dict(l=30, r=30, t=30, b=30),
-+            paper_bgcolor="#4d4d4d",
-+            plot_bgcolor="#4d4d4d",
-+            polar=dict(
-+                bgcolor="#4d4d4d",
-+                radialaxis=dict(visible=True, range=[0, self.maxRadius], tickvals=[100, 200]),
-+                angularaxis=dict(rotation=90, direction="clockwise",)   # rotate CCW
-+            ),
-+            font=dict(color="white"),
-+            #showlegend=True
-+        )
-+
-+        return figure
-+
-+
-+    def toggle_GUI(value):
-+        if value == "CURRENT":
-+            pastPlotContainer.visible = False
-+            currentPlotContainer.visible = True
-+        elif value == "PAST":
-+            currentPlotContainer.visible = False
-+            pastPlotContainer.visible = True
-+        elif value == "STATIONARY OBJECTS":
-+            currentPlotContainer.visible = False
-+            pastPlotContainer.visible = False
-+        else:
-+            raise ValueError("Invalid time slice")
-+
-+
- if __name__ in {"__main__", "__mp_main__"}:
- 
--    EP3 = Radar()
--    EP3.update_radar(True, 60, 0, PAST)
--    EP3.update_radar(True, 50, 0, CURRENT)
--    EP3.update_radar(True, 100, 0, CURRENT)
--    EP3.update_radar(True, 100, 1, CURRENT)
--    EP3.update_radar(True, 100, 2, CURRENT)
--    EP3.update_radar(True, 100, 3, CURRENT)
--    EP3.update_radar(True, 101, 3, CURRENT)
--    EP3.update_radar(True, 102, 4, CURRENT)
--    EP3.update_radar(True, 108, 5, CURRENT)
--    EP3.update_radar(True, 103, 4, CURRENT)
--    EP3.update_radar(True, 40, 0, NEXT)
--    #stationaryObjects = EP3.find_stationary_points(10, 2)
--    print(EP3.get_points())
--
--    #print(EP3)
--
--    radius, theta = EP3.create_plot_points(EP3.dataTimeSliceCurrent)
--
--
--    fig = go.Figure(go.Scatterpolar(r= radius, theta= theta,
--        mode="markers",
--        marker=dict(size=4, color="red"),
--        name="Detection"))
--
--    fig.update_layout(
--        margin=dict(l=60, r=60, t=30, b=30),
--        paper_bgcolor="#4d4d4d",
--        plot_bgcolor="#4d4d4d",
--        polar=dict(
--            bgcolor="#4d4d4d",
--            radialaxis=dict(visible=True, range=[0, 300], tickvals=[100, 200]),
--            angularaxis=dict(rotation=90, direction="clockwise",)   # rotate CCW
--        ),
--        font=dict(color="white"),
--        #showlegend=True
--    )
--
--    plot = ui.plotly(fig).classes('justify-center w-full h-[500px]')
--    ui.button("Perform new RADAR scan", icon='radar', on_click= lambda: EP3.next_scan()).props('color=orange').classes('justify-center w-full')
-+    EP3 = Radar(300, '/dev/ttyUSB0', 'TESTING')
-+    EP3.generate_random_data(100)
-+    EP3.update_radar_database(True, 60, 0, Radar.PAST)
-+
-+    with ui.row().classes('justify-center w-full'):
-+        currentPlotContainer = ui.plotly(EP3.GUI("CURRENT")).classes('w-[600px] h-[525px]')
-+        pastPlotContainer = ui.plotly(EP3.GUI("PAST")).classes('w-[600px] h-[525px]')
-+        stationaryPlotContainer = ui.plotly(EP3.GUI("STATIONARY OBJECTS")).classes('w-[600px] h-[525px]')
-+        pastPlotContainer.visible = False
-+        stationaryPlotContainer.visible = False
-+
-+    ui.button("Perform new RADAR scan", icon='radar', on_click= lambda: EP3.next_scan(currentPlotContainer, pastPlotContainer)).props('color=orange').classes('justify-center w-full')
-     with ui.row().classes('items-center'):
--        ui.label("Time Slice:")
--        radioTimeSliceInput = ui.radio(["PAST", "CURRENT"], value="PAST").props('inline')
-+        ui.label("RADAR Time Slice:")
-+        radioTimeSliceInput = ui.radio(["CURRENT", "PAST", "STATIONARY OBJECTS"], value="CURRENT", on_change= lambda e: Radar.toggle_GUI(e.value)).props('inline').classes('mr-2')
- 
--    ui.run(native=True, dark=True, window_size=(720, 720), title='RADAR Data', on_air=None)
-+    ui.run(native=True, dark=True, window_size=(660, 720), title='RADAR Data', on_air=None)
